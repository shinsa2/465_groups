// Generated by CoffeeScript 2.2.4
(function() {
  /*
    Rudimentary code for creating groups of students randomly for our ICS 465 and ICS 665 courses.
    Note: The text in table this app created can be easily pasted into as sheet on our Drive which then can be pasted
      into the assignments document.
    Obviously, there should be possible to generate the groups in a sheeet directly using Google App Script, or even
    generate the table in a document, but this would need quite some expertise in App Script and it's UI...
    Copyright 2/2020 Jan Stelovsky, UH Manoa ICS
    MIT license: Use any way you please, just don't complain...
  */


  /* ########## STUDENT COMMENTS ##########
    Dennis made changes to the HTML file to show only 465 roster instead of both 465 and 665.
    Changed the js file to make groupSize variable to an integer, took away 665 roster, added a window prompt to change
    the groupSize variable, which then updates the new groups every time the user enters a size.

    Sunny made changes to the window prompt to a text box for user input. Moved groupSize variable update into the
    makeGroups() function.

    Chris made changes to the HTML section of the app. This included format, colors and input constraints. In addition
    file input was considered but not required as due to project requirements.
  */

  var clone, groupSize;

  // Shuffles this array. Must be called on the array
  // Returns the changed array
  // Probably the simplest useful algorithm...
  // Note: '@' in CS translates to 'this.' in JS
  Array.prototype.shuffle = function() { // '::' translates to '.prototype.' - see the corresponding js file
    var i, j;
    i = this.length;
    // for all array indices i except the 0th going backwards
    while (i > 1) {
      // get random index in [0..i]
      j = Math.floor(Math.random() * i--);
      // switch items i and j; note that exchanging
      [this[i], this[j]] = [this[j], this[i]];
    }
    return this;
  };


  // Returns the deep clone of 'value'
  // Note: 'value' cannot have internal references, i.e., no descendent can refer to another descendent
  clone = function(value) {
    return JSON.parse(JSON.stringify(value));
  };

  // sizes of a group per course
  // note: there may be groups that have one more students
  groupSize = 3;

  // Main app body run when page is loaded and its elements are accessible.
  $(function() {
    var courses, dom, id, k, len, makeGroups, ref, show, update;
    // DOM elements, courses
    [dom, courses] = [{}, {}, {}];
    ref = ['groups', 'ics465', 'ics665', 'ics465_csv', 'ics665_csv'];
    for (k = 0, len = ref.length; k < len; k++) {
      id = ref[k];
      dom[id] = $(`#${id}`);
    }
    $.when($.get({
      url: 'assets/465_roster.tsv',
      dataType: 'text'
    }), $.get({
      url: 'assets/665_roster.tsv',
      dataType: 'text'
    })).then(function(ics465) {
      var rosters;
      // rosters from data read
      // note: jQuery's $.when()...then() is inconsistent in handling one or multiple arguments
      //   with 1 argument of $.when(), argument of then() is just a value
      //   with more arguments of $.when(), the arguments of then() are all arrays
      //     so to get each of the values we must access the 0th item of the array
      // (UI principle violated: Consistency)
      rosters = {
        ics465: ics465[0]
      };
      // make courses from rosters
      courses = update(rosters);
      return dom.groups.click(function() {
        return makeGroups();
      }).trigger('click',);
    }).fail(function() {
      return '"assets/roster_465.tsv" and/or "assets/roster_665.tsv" missing';
    });
    // Returns 'courses' based on 'rosters' where each student's email stub is enclosed in '(' and ')'.
    // Note: each line in 'rosters' contains two tab-separated items: the student's name, and her email stub
    update = function(rosters) {
      var i, key, l, len1, ref1, student, tsv;
      for (key in rosters) {
        tsv = rosters[key];
        courses[key] = [];
        ref1 = tsv.split('\n');
        // for each line in 'tsv', make a line in 'courses' with name and email stub enclosed in '(' and ')'
        for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
          student = ref1[i];
          courses[key][i] = student.replace(/\t(.*)/, " ($1)");
        }
      }
      return courses;
    };

    makeGroups = function() {
      groupSize = document.getElementById("size").value;

      var group, groups, i, j, key, l, len1, m, n, ref1, ref2, size, student, students;
      for (key in courses) {
        students = courses[key];
        [groups, size] = [[], groupSize];
        // preserve the original 'students'; now 'students' can be emptied
        students = clone(students);
        // randomize 'students'
        students.shuffle();
// make 'groups' that have exactly 'size' number of 'students'
        for (i = l = 0, ref1 = Math.floor(students.length / size); (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
          group = [];
          for (j = m = 0, ref2 = size; (0 <= ref2 ? m < ref2 : m > ref2); j = 0 <= ref2 ? ++m : --m) {
            group.push(students.pop()); // pop() and push() are likely more efficient than splice(), shift(), unshift()
          }
          groups[i] = group;
        }
// if there are still some 'students' left, distribute each into subsequent 'groups' starting with group 0
        for (i = n = 0, len1 = students.length; n < len1; i = ++n) {
          student = students[i];
          groups[i].push(student);
        }
        // display the 'groups'
        show(key, groups);
      }
      return null; // returning 'null' prevents CS from creating and returning a useless array
    };

    // Makes the list of groups for the 'key' course within the corresponding 'ui' element in the table cell
    return show = function(key, groups) {
      var group, i, l, len1, text;
      // clear the previous entries in the list
      dom[key].empty();
// add a 'li' element with names and email stubs for all students in a 'group' separated by ','
      for (i = l = 0, len1 = groups.length; l < len1; i = ++l) {
        group = groups[i];
        text = `Group ${i + 1},${group.join(',')}`;
        $('<li>').text(text).appendTo(dom[key]);
      }
      return null; // again, don't make
    };
  });

}).call(this);